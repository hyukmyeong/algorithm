# 6장. 무식하게 풀기
## 6.0

- 알고리즘 문제를 접하면 모니터만 멍하니 보게 될 수 있다
- 그러나 고수들도 한순간의 영감으로 문제를 해결하지 않으며, 전략적인 선택을 하게 된다
- 전략적인 선택이란 문제를 이해하고, 적절한 자료구조 선택하고, 또 알고리즘을 설계하는 것이다
- 이러한 전략적인 선택은 패턴이 있기 때문에 학습과 경험을 통해그  능력을 향상시킬 수 있다
- 6장~12장은 먼저 알고리즘 설계 패턴(패러다임)을 익힌다
- 알고리즘 설계 패턴 : 무식하게 풀기, 분할정복, 동적 계획법, 탐욕법, 조합 탐색, 최적화 문제
- 16장~32장은 자료구조를 익힌다

## 6.1 도입

* 프로그래밍 대회에서 가장 많이 하는 실수는 어렵고 이쁘게만 문제를 풀려고 하는 것이다
* 일단, 무식하게 풀 수 있을까? 라고 스스로에게 물어보자 
* 무식하게 푼다 = brute-force
* 쉽게 말하면
  * 무식하게 풀기란? 주어진 문제에서 가능한 **모든 경우의 수**를 무식하게 다 해보는 것이다
  * 모든 경우의 수를 다 해보는 것은? **완전탐색** 이라고 한다
  * 완전탐색하는 방법은? 반복문과 **재귀호출** 이 있다
* 예를 들면
  * 문제
    * 10명의 학생을 한 줄로 세우려고 한다
    * 서로 사이가 안 좋은 학생들이 있어서 붙여놓면 싸운다
    * 그래서 사이가 안 좋은 학생들은 떨어뜨려서 세워야 한다
    * 위를 만족하는 경우가 존재하는지 찾아라
  * 무식하게 풀기
    * 해결방법을 모르겠다!
    * 그냥 모든 경우의 수를 다 계산한다!  (10! = 3,628,800) 
    * 계산하면서 위의 조건을 만족하는 경우를 찾는다!
  * 시간제한에 걸리지 않고 성공 가능할까?
    * 360만이면 많게 보이지만 주먹구구 법칙(10억 미만이면 OK)을 생각하면 충분히 가능한 데이터량이다

## 6.2 재귀호출과 완전 탐색 

* 재귀 호출 
  * 반복문과 목적은 동일하지만, 알고리즘 구현 시 유용하게 사용할 수 있다
  * 예제
    * 자연수 n이 주어졌을 때, 1~n까지의 합을 반환하는 함수
    * 반복문과 재귀함수로 구현
    * 소스코드 (코드 6.1)
      ```c++
      // 필수 조건 : n >=1
      // 결과 : 1부터 n까지의 합을 반환한다
      int sum(int n) {
          int ret = 0;
          for(int i=1; i<=n; ++i)
              ret += i;
          return ret;
      }
      
      // 필수 조건 : n >= 1
      // 결과 : 1부터 n까지의 합을 반환한다
      int recursiveSum(int n) {
          if(n == 1) 
              return 1;
          return n + recursiveSum(n-1);
      }
      ```
    * 재귀함수로 변환할 때 주의할 점
      * 기저사례(base case) 를 꼭 확인하고 구현하기
      * 즉, 2~n 까지는 동일한 계산방법(**조각**)을 사용하지만 **1** 은 그렇지 않다
      * 이처럼 동일한 계산방법이 아닌 것, 즉 기저사례는 직접 코딩 해야한다
    * 결론적으로 반복문과 재귀함수의 다른점은,
      재귀함수는 이러한 조각을 찾아서 반복호출면서 기저사례를 예외처리 해주는게 핵심이다
* 예제: 중첩 반복문 대체하기
  * 문제
    * 0부터 차례대로 번호 매겨진 n개 중 4개를 고르는 모든 경우를 출력
    * 만약 n=7 이라면, 
      * (0,1,2,3), (0,1,2,4), (0,1,2,5), ... , (3,4,5,6)
      * 7C4 = 7! / 4!3! = 35가지
  * 반복문 구현
    ```c++
    for (int i=0; i < n; ++i)
        for (int j=i+1; j < n; ++j)
            for (int k=j+1; k < n; ++k)
                for (int l=l+1; l < n; ++l)
                    cout << i << " " << j << " " << k << " " << l << endl;
    ```
    * 4개를 고를 땐 반복문 4개가 중첩된다
    * 만약, 5개를 고른다면 반복문 5개가 중첩된다
    * 이처럼 반복문이 계속 중첩되는 모습이 된다
    * 즉, 완전탐색을 할 때 반복문을 사용하면 코드가 길어지고 복잡해지는 경우가 발생한다
  * 재귀함수 구현
    * 우선 위의 반복문을 보면 for문 1개당 하나의 원소를 고른다
    * 재귀함수는 1개 함수이므로 주업무를 어떤것으로 할지 잘 골라야 한다
      * 이 때는 문제를 **조각** 낸 후에 가장 중요한 동작을 재귀함수의 주요 동작으로 선택한다
      * **조각**을 기억하자
    * 또한, 재귀함수가 필요로하는 파라미터를 정의할 수 있어야 한다
      * 원소들의 총 개수
      * 지금까지 고른 원소들의 번호
      * 더 골라야 할 원소들의 개수
    * 소스코드 (코드 6.2)
      ```c++
      // n : 원소들의 총 개수
      // picked : 지금까지 고른 원소들의 번호
      // toPick : 더 골라야 할 원소들의 개수
      void pick(int n, vector<int>& picked, int toPick) {
          // 기저사례 : 더 고를 원소가 없을 때, 원소들을 출력한다
          if (toPick == 0) {
              printPicked(picked); 
              return;
          }
          
          // 고를 수 있는 가장 작은 번호를 계산한다
          int smallest = picked.empty() ? 0 : picked.back() + 1;
          
          // 이 단계에서 원소 하나를 고른다
          for(int next = smallest; next < n; ++next) {
              picked.push_back(next);
              pick(n, picked, toPick-1);
              picked.pop_back();
          }
      }
      ```
    * 위의 소스코드는 반복문이 하나만 사용됐다
    * 재귀함수를 쉽게 이해하기 위한 그림을 보면 아래와 같다
    ![](https://github.com/ant35rookie/share/blob/master/docs/ch6/22.jpg)
      * 가정 : n = 4 일 때, 3개를 고르기 (4C3 = 4! / 3!1! 이므로 결과는 총 4개가 나와야 한다)

* 예제: 보글 게임 (난이도 : 하)
  * 문제
    * 5x5 크기의 알파벳 격자를 가지고 하는 게임
    * **상하좌우 및 대각선**으로 인전합 칸들의 글자를 이어서 단어를 찾아내는 게임
    * 예를 들어 아래 그림 b, c, d  의 답은 각각 PRETTY, GIRL, REPEAT 이다
    * 아래 그림에서 a, e 와 같은 격자와 찾고자 하는 단어가 주이지면, 해당 단어가 있는지 검사하는 함수 구현
    * 시작점은 주어짐
    ![](https://github.com/ant35rookie/share/blob/master/docs/ch6/11.jpg)
  * 생각해볼 점
    * 위 그림 e 는 YES 라는 단어를 찾는 것이다
    * 시작점이 정가운데 Y 라고 하면, 가능한 E가 모든 방향으로 8개나 된다
    * 정답은 우측 상단 대각선인데, 이것을 어떻게 하면 알 수 있을까?
  > 여기서도 무식하게 풀어보는 것이다, 즉 모든 경우의 수를 다 해본다
  * 문제의 분할
    * 조각을 내보자
      * 각 칸과 현재 찾고 있는 음절을 비교하는 것을 하나의 조각으로 보면 자연스럽다
    * 재귀함수이 이름과 필요한 파라미터는 아래와 같이 정의할 수 있다
      * hasWord(y, x, word)
    * 파라미터는 y,x 는 시작점, word는 찾는 단어
  * 기저 사례 고르기
    * 먼저, 추가진행할 필요가 없이 결정되는 사항들을 찾고 예외처리 해야한다
      1. 위치 (y,x)에 있는 글자가 원하는 단어의 첫 글자가 아닌 경우 항상 실패
      2. (1번이 아니고) 원하는 단어가 1글자일 때 항상 성공
    * 더불어서 입력이 잘못된 경우를 찾고 예외처리 해야한다
      1. 범위오류
       (이런 기본적인 얼토당토 않은 기저사례를 찾았다면 코딩할 때 기저사례 중에서도 윗부분에 적어주는게 좋다)
* 구현
    ```c++
    const int dx[8] = {-1, -1, -1,  1, 1, 1,  0, 0};
    const int dy[8] = {-1,  0,  1, -1, 0, 1, -1, 1};
    
    // 5x5의 보글게임판에서 주어진 단어가 있는지를 확인하는 함수
    bool hasWord(int y, int x, const string& word) {
    	// 기저사례 1: 시작 위치가 범위 밖이면 무조건 실패
    	if(!inRange(y, x))
    		return false;
        
    	// 기저사례 2: 첫 글자가 일치하지 않으면 실패
    	if(board[y][x] != word[0])
    		return false;
    		
    	// 기저사례 3: 단어 길이가 1이면 성공
    	if(word.size() == 1) return true;
    	
    	// 인접한 여덟 칸을 검사한다
    	for(int direction=0; direction <8; ++direction) {
    		int nextY = y + dy[direction], nextX = x + dx[direction];
    		
    		// 다음 칸이 범위 안에 있는지, 첫 글자는 일치하는지 확인할 필요가 없다
    		if(hasWord(nextY, nextX, word.substr(1)))
    			return true;
    	}
    	return false;
    }
  ```
    * 위의 재귀함수를 쉽게 이해하려면
      * 문제의 정의가 boolean 을 최종적으로 return 하는 것이 목적임을 정확히 파악하고 있어야 하며
      * 그래서 가능한 경우를 하나라도 찾으면 true 가 연쇄적으로 일어나서 최종 return 하는 구현이다
    * 바로 다음글자 8개중에 true가 없으면 현재 글자도 false를 return하고 있다
* 시간복잡도 분석
    * 사실, 완전탐색의 경우 모든 경우의 수를 무식하게 푸는 것이므로 대개의 경우에 시간복잡도 계산도 단순하다
    * 그렇긴 하지만, 보글 게임에서 사용한 알고리즘은 해답을 찾으면 바로 리턴하기 때문에 까다로움이 더해진다
    * 일단, 최악의 경우만 고려해보자
      * 8x8 격자에서 답이 없었다고 한다면, 모든 경우의 수가 곧 시간복잡도가 된다
      * 단어의 길이수 마다 8개의 재귀함수를 호출한다 (8개 방향)
      * 마지막 글자는 기저사례 3 에 의해 제외되므로, 시간복잡도는 8^n-1 = O(8^n) 이 된다
    * 8^n 은 지수복잡도이다
    * 지금은 데이터량이 작지만, 지수복잡도는 데이터가 조금만 커져도 문제가 될 것이다
    * 이렇듯 무식하게 풀기는 데이터량 (여기서는 단어길이) 에 따라 실패할 수도 있다
  * 8장에서는 배우는 동적계획법을 통해 이를 개선해보자
* 완전탐색 레시피
    * 완전 탐색으로 문제를 해결하는 과정
    * 모든 경우에 적용되는 것은 아니지만, 대략적인 지침으로 기억하면 좋음
      1. 완전 탐색은 존재하는 모든 답을 검사하므로 걸리는 시간은 측정이 용이한 측면이 있다
         따라서 완전 탐색 or 무식하게 풀기 or brute-force 로 주어진 문제를 풀 수 있을지 빠르게 판단하자
         만약, 불가능하다면 또다른 알고리즘 전략을 채택해야 한다
      2. 완전 탐색을 수행하는 과정을 여러개의 조각으로 나누자
      3. 그 중 하나의 조각을 선택해 완전 탐색의 일부를 만들고, 완전탐색의 나머지는 재귀 호출을 통해 완성한다 (이전에 나온 4중 for 문에서 1개만 재귀함수에서 수행하고, 나머지는 재귀호출을 했다)
      4. 더 이상 진행할 수 없는 경우를 파악하여 기저 사례를 꼭 처리하자
* 이론적 배경: 재귀 호출과 부분 문제
  * 재귀 호출을 공부하면서 짚고 넘어가야할 개념
    * 문제와 부분문제 (problem & subproblem)
  * 위 개념은 다음에 배울 동적계획법이나 분할정복에서도 사용되므로 중요하다
  * 일단, 문제의 정의란 무엇인가 생각해보자
    * 아래 2개 문제를 봐보자
      * 문제 #1 : 주어진 자연수 수열을 정렬하라
      * 문제 #2 : {16, 7, 9, 1, 31} 을 정렬하라
    * 얼핏 보면 비슷하지만, 큰 차이가 있다
      * 재귀함수에서는 자료의 조합이 정말 중요하다
        심지어 {1,2,3} 을 정렬하는 것과 {3,2,1}을 정렬하는 문제도 서로 다르다
      * 따라서, 위의 문제 2개는 엄밀히 다른 문제이고, 전자는 범위가 없으므로 문제의 정의라고 보기도 어렵다
  * 이제, 문제와 부분문제의 차이점을 통해 이해하고 조각도 찾아볼 수 있다
    * 보글게임의 완전탐색 과정 (즉, **조각**) 을 보면 아래와 같다
      1. 현재 위치 (y, x) 에서 단어의 첫 글자가 있는가?
      2. 상단 (y-1, x) 에서 시작해서, 단어의 나머지 글자들을 찾을 수 있는가?
      3. 좌상단 (y-1, x-1) 에서 시작해서, 단어의 나머지 글자들을 찾을 수 있는가?
      4. ...
      5. ...
    * 최종적으로 총 9개의 **조각**이 나오겠지만 사실 2~9번은 1번으로 부터 파생된 것이다
    * 이 때, 1번은 문제라고 하고, 2~9 은 부분문제가 된다 

## 6.3 문제: 소풍 (난이도: 하)

* 문제
  * 유치원에서 소풍감
  * 선생님은 2명씩 짝을 지어주려 함
  * 친구가 아닌 아이들을 짝지어주면 싸워서 안됨
  * 일부만 달라도 다른 방법이라고 봄, 따라서 아래 2가지는 다른 방법임
    * #1 - (태연, 제시카), (써니, 티파니), (효연, 유리)
    * #2 - (태연, 제시카), (써니, 유리), (효연, 티파니)
* 시간 & 메모리 제한
  * 1초 내 실행, 64MB 이하의 메모리
* 입력
  * 첫 줄에는 테스트 케이스의 수 C (C<=50)
  * 각 테스트 케이스
    * 첫번째 줄 : 학생의 수 n (2 <= n <= 10) , 친구 쌍의 수 m (0 <= m <= n(n-1) / 2)
    * 두번째 줄 : 친구 쌍 
* 출력
  * 각 테스트 케이스마다 모든 학생을 친구끼리만 짝지어줄 수 있는 방법의 수를 출력
* 예제 입력

  ```shell
  3
  2 1
  0 1
  4 6
  0 1 1 2 2 3 3 0 0 2 1 3
  6 10
  0 1 0 2 1 2 1 3 1 4 2 3 2 4 3 4 3 5 4 5
  ```
* 예제 출력
  ```shell
  1
  3
  4
  ```
* 예제 입출력 설명
  * 첫 번째 테스트케이스
    * (2 1)은 학생이 2명이고 짝이 1개 이므로 답도 1개
  * 두 번째 테스트케이스
    * (4 6)은 학생이 4명이고 6개 짝이므로 모두 친구라는 의미가 됨 (4C2 = 총 6개)
    * 4명을 A,B,C,D라고 할 때, 최종적으로 아래와 같은 3가지 방법이 가능함을 알 수 있다
      * (A, B) (C, D)
      * (B, D) (A, C)
      * (C, A) (A, D)

## 6.4 풀이: 소풍

* 완전 탐색
  * 역시 완전 탐색이 어울리는 문제이며 재귀 호출을 이용해 코드를 작성해 보자
  * 조각 정하기
    * 2명씩 짝을 짓는 문제이니 전체 학생 n에 대해 n/2 개의 조각이 있다고 하자
    * 그리고 한 조각에서는 2명을 짝지어주는 것을 목표로 하자
    * 그럼 재귀함수는 주어진 학생들 중에서 계속해서 2명을 짝지어주는 것이 된다
* 1차 코드 (코드 6.4))
  ```c++
  // 전체 학생의 수
  int n;
  // 친구배열
  //   0 1 2 3 ... 
  // 0 x o x o
  // 1 o x x x
  // 2 x x x o
  bool areFriends[10][10];
  
  // taken[i] = i번째 학생이 짝을 이미 찾았으면 true, 아니면 false
  int countParings(bool taken[10]) {
  	// 기저사례: 모든 학생이 짝을 찾았으면 가능한 1가지 경우를 찾았다고 상위에 알려준다
  	// taken[i] 가 모두 true 이므로 짝이 없는 친구가 없는 것임
  	bool finished = true;
  	for(int i =0; i<n; ++i)
  		if(!taken[i]) finished = false;
      if(finished)
      	return 1;
    
      // ret 에 주목해보자
      // 이 함수는 가능한 경우의 수를 모두 찾는 것이다, 따라서 ret을 계속 더해가는 구조이다
      // 만약 친구들을 모두 검색했는데, 그런 경우를 못 찾으면 ret=0 을 반환하므로
      // 해당 경우는 짝지을 수 있는 방법이 없는 것이다, 즉 집계되지 않는다
  	int ret=0;
      // 서로 친구인 두 학생을 찾아 짝을 지어 준다
      for(int i=0; i<n; ++i) {
          for(int j=0; j<n; ++j) {
              // i, j 가 친구가 없는데, 둘이 친구이면
              if(!taken[i] && !taken[j] && areFriends[i][j]) {
                  taken[i] = taken[j] = true;
                  ret += countPairings(taken);
                  taken[i] = taken[j] = false;
              }
          }
      }
      return ret;
  }
  ```
  * 소스코드 이해하기 (그림)
  ![](https://github.com/ant35rookie/share/blob/master/docs/ch6/33.jpg)
  * 근데 실행해보면, 답이 1 3 4 로 나오지 않음
  * 위 코드의 문제점?
    * 중복으로 세는 것이 발생
    * (0 1) 과 (1 0) 을 별개로 취급함
    * 이러한 문제는 매우 자주 발생하기 때문에 유의해야 함
  * 해결법
    * 빠른 번호부터 찾는 것으로 순서를 강제함
    * 다음에는 남아있는 학생들중에서 번호가 빠른 아이를 또 찾아 주도록 함
    * 그러면 (0 1) 은 찾게 되지만, (1 0) 과 같은 역순은 발생할 수 없음
* 2차 코드 (코드 6.5)
  ```c++
  int n;
  bool areFriends[10][10];
  
  // taken[i] = i번째 학생이 짝을 이미 찾았으면 true, 아니면 false
  int countParings(bool taken[10]) {
      // 남은 학생들 중 가장 번호가 빠른 학생을 찾는다
      int firstFree = -1;
      for(int i=0; i <n ++i) {
          if(!taken[i]) {
              firstFree = i;
              break;
          }
      }
      
      // 기저사례: 모든 학생이 짝을 찾았으면 가능한 1가지 경우를 찾았다고 상위에 알려준다
      // taken[i] 가 모두 true 이므로 짝이 없는 친구가 없는 것임
      if(firstFree == -1)
          return 1;
      
      int ret = 0;
      // 이 학생과 짝지을 학생을 결정한다
      // firstFree + 1 이 핵심이며 바로 다음순서 학생부터 검색시작함을 의미한다
      for(int pairWith = firstFree+1; pairWith <n; ++pariWith) {
          if(!taken[pairWith] && areFriends[firstFree][pairWith]) {
              taken[firstFree] = taken[pairWith] = true;
              ret += countPairings(taken);
              taken[firstFree] = taken[pairWith] = false;
          }
      }
      return ret;
  }
  ```
  * 소스코드 이해하기 (그림)
  ![](https://github.com/ant35rookie/share/blob/master/docs/ch6/44.jpg)
  * 위 코드에서 답으로 가능한 최대개수
    * 학생 수 10명이 서로 모두 친구인 경우
    * 9 x 7 x 5 x 3 x 1 = 945
      * 첫번째 학생은 9개의 선택지 - 2명 짝지어짐
      * 세번째 학생은 7개의 선택지 - 4명 짝지어짐
      * ...
* 재귀함수를 구현하고자 할 때, 3가지를 잘 생각해보자
  * 조각으로 할 것
  * 반환할 것 (boolean 인지?  int 인지?)
  * 함수간에 공유할 것 (파라미터)

## 6.5 문제: 게임판 덮기 (난이도: 하)

* 문제
  * H x W 크기의 격자무늬 게임판이 있다
  * 각 칸은 검은색 혹은 흰색이다
  * 흰 칸을 세가지 칸을 차지하는 L 자 모양 블럭으로 채우려고 한다
  * 테트리스처럼 회전할 수는 있지만, 검은칸이나 이미 덮은 흰칸을 채우면 안된다
  * 모든 흰 칸을 채우는 방법의 수를 구해라
* 시간 & 메모리 제한
  * 2초안에 실행되어야 하고, 64MB 이하의 메모리만 사용  
* 예제
  ![](https://github.com/ant35rookie/share/blob/master/docs/ch6/66.png)
* 입력
  * 첫 줄 : 테스트케이스 수 C (C <= 30)
  * 각 테스트케이스
    * 첫번째 줄 : H , W (1 <= H, W <= 20)
    * 두번째 줄 : 게임판의 모양 # (검은칸)  / . (흰칸)
* 출력
  * 한 줄에 하나씩 흰 칸을 모두 덮는 방법의 수를 출력하라
* 예제 입력

  ```shell
  3
  3 7
  #.....#
  #.....#
  ##...##
  3 7
  #.....#
  #.....#
  ##..###
  8 10
  ##########
  #........#
  #........#
  #........#
  #........#
  #........#
  #........#
  ##########
  ```

* 예제 출력

  ```shell
  0
  2
  1514
  ```
* 예제 설명
  * 첫번째 예제 : 빈칸이 13개 이므로 L (3칸짜리) 로 다 채울 수 없다
  * 두번째 예제 : 아래와 같이 2가지 방법으로 덮을 수 있다
  ![](https://github.com/ant35rookie/share/blob/master/docs/ch6/77.png)

## 6.6 풀이: 게임판 덮기

* 문제가 방법의 수를 찾는 것이므로 무식하게 풀기(완전탐색) 를 이용해 풀 수 있다
* 아래와 같이 법칙을 찾는다
  * 흰 칸의 수가 3의 배수가 아니면 무조건 실패다
  * 3의 배수가 아니면 아래의 순서로 진행한다
    * 빈칸 / 3 = N 을 구한다, N은 L자 블록의 개수가 된다
    * 여기서 조각은 한 블럭을 놓는 것을 계산하는 것이 된다
    * 따라서 재귀함수는 한 블록을 내려놓는 것을 기본으로 하고 나머지는 재귀함수를 호출해서 해결한다
* 중복으로 세는 문제
  * 문제에는 블록을 어디에 놓든 (어떤 순서로 놓든) 제한이 없다
  * 근데, 그렇게 되면 재귀함수에서 중복되는 부분을 피할 수 없다
    (완전탐색을 하다보면 시작위치에 따라서 중복되는 경우가 발생하기 때문에)
  * 따라서 시작위치를 강제화 한다
  * 중복을 제거할 때 조금 다른 점은 아래와 같다
    * 소풍문제 : 다음으로 큰 숫자를 지정함을 통해 불필요한 재귀함수를 호출하지 않음
    * 게임판덮기 문제 : 블록 놓는 순서를 강제화해서 이미 찾은 것은 아예 재귀함수를 호출하지 않음
  * 2장 - 문제해결 과정 을 remind 해보면
    * 비슷한 유형 떠올려보기
    * 단순하세 시작할 수 있을까?
    * 손으로 해보기
    * 단순화하기
    * 그림 그려보기
    * 수식화 해보기
    * 분해해보기
    * 뒤에서부터 생각하기
    * **순서를 강제로 만들기**
    * 정규화된 답을 찾기
  * 순서를 강제로 만들기를 생각하면서, 왼쪽 위에서 부터 차례대로 블럭을 채운다고 해보자
    * 어떤 시작점에서 보면, 왼쪽과 상단은 모두 채워져 있다는 전제가 생긴다
    * 그럼 해당 시작점에서 L 블럭을 놓을 수 있는 경우의 수는 4개이다
  * 답의 수의 상한
    * 최대크기인 테스트케이스 3번의 경우 빈칸이 48개 이므로 블럭은 16개가 가능하다
    * 그럼 가능한 답의 수 = 4^16 = 4,294,967,296 이 되어야 한다 (한 블럭당 4가지 경우가 가능하므로)
    * 이것은 주먹구구 방법을 넘어선다, 그러나 실제로는 그렇게 값이 크지 않음을 직관적으로 알 수 있다
    * 예를 들어,
      * 빈칸이 6칸이 있는 경우, 블럭은 2개
      * 가능한 답의 수 = 4^2 = 16가지 방법이 나와야 하는데, 실제로는 2가지 밖에 없다
  * 구현 (코드 6.6)
    ```c++
    // 주어진 칸을 덮을 수 있는 4가지 방법
    // 블록을 구성하는 세 칸의 상대적 위치 (dy, dx) 의 목록
    const int coverType[4][3][2] = {
        { {0, 0}, {1, 0}, {0, 1} },  // 그림에서 블럭 b
        { {0, 0}, {0, 1}, {1, 1} },  // 그림에서 블럭 c
        { {0, 0}, {1, 0}, {1, 1} },	 // 그림에서 블럭 d
        { {0, 0}, {1, 0}, {1,-1} }   // 그림에서 블럭 e
    };
    
    // set 함수 : board의 (y, x)를 type 방법 덮거나, 덮었던 블록을 없앤다
    // delta = 1 이면 덮고, delta = -1 이면 덮었던 블록을 없앤다
    // 만약 블록이 게임판 밖으로 나가거나, 서로 곂치거나, 검은 칸을 덮을 때는 false를 리턴한다
    bool set(vector<vector<int>>& board, int y, int x, int type, int delta) {   
        
        // 왜 return false, return true를 바로 하지 않고
        // bool ok 와 같이 변수를 선언해서 진행할까?
        // 만약 L자모양이 사용하는 3개지 좌표 중에 1군데만 바꾸고 빠져나가면
        // 남은 칸은 1,0,-1 의 범위를 넘어설수도 있다
        // 그렇게 되면 어떤 좌표는 영원히 덮이지 않거나 또는 영원히 덮여 있을수도 있다
        bool ok = true;
        
        // 각 블럭을 놓을 수 있는 점 3개가 사용가능한지 확인
        for(int i=0; i<3; ++i) {
            const int ny = y + coverType[type][i][0];
            const int nx = x + coverType[type][i][1];        
            // 블록이 게임판 밖으로 나간 경우임
            if(ny < 0 || ny >= board.size() || nx < 0 || nx >= board[0].size())
                ok = false;
            // 검은칸이거나 이미 덮인 칸임, += 를 통해 대입하고 있다
            // 대입이 덮거나 치우는 행위를 의미한다
            else if((board[ny][nx] += delta) > 1)
                ok = false;
        }
        return ok;
    }
    
    // cover(재귀함수) : board의 모든 빈 칸을 덮을 수 있는 방법의 수를 반환한다
    // board[i][j] = 1 이면, 이미 덮인 칸 혹은 검은 칸
    // board[i][j] = 0 이면, 아직 덮이지 않은 흰 칸
    int cover(vector<vector<int>>& board) {
        // 아직 채우지 못한 칸 중 가장 윗줄 왼쪽에 있는 칸을 찾는다
        int y = -1, x = -1;
        for(int i = 0; i < board.size(); ++i) {
            for(int j = 0; j < board[i].size(); ++j) {
                if(board[i][j] == 0) {
                    y = i;
                    x = j;
                    break;
                }
            }
            // 찾았으면 for문을 빠져나오고 못 찾았으면 계속 찾는다
            if(y != -1)
                break;
        }
        
        // 기저사례 : 모든 칸을 채웠으면 1을 반환한다 (빈 칸을 못 찾았으므로)
        if(y == -1)
            return 1;
        
        int ret = 0;
        for(int type = 0; type < 4; ++type) {
            // 만약 board[y][x]를 type 형태로 덮을 수 있으면 재귀 호출한다
            if(set(board, y, x, type, 1))
                ret += cover(board);
           	// 덮었던 블록을 치운다
            // 블록을 덮어두면 다음 경우를 찾을 때, 진행이 불가능하므롤
            // ret 은 이미 +1 되어 위로 전달될 것이기 때문에 문제 없다
            set(board, y, x type, -1);
        }
        return ret;
    }
    ```
    * 소스코드 이해하기
    ![](https://github.com/ant35rookie/share/blob/master/docs/ch6/55.png)

## 6.7 최적화 문제

* 최적화 문제란 무엇일까?
  * 지금까지는 여러개의 답을 찾아보는 문제를 다뤘다 (가능한 경우의 수 찾기 or 가능한지 알아보기 등)
  * 최적화 문제(Optimization Problem)는 여러개의 답 중에 가장 좋은 답을 찾아내야 하는 조금 다른 문제이다
  * 예를 들어
    * "n개의 원소 중에서 r개를 순서 없이 골라내는 방법의 수를 구하라" 는 최적화 문제일까?
    * "n개의 사과 중에서 r개를 골랐을 때, 무게의 합을 최대인 것을 구하라" 는 최적화 문제일까?
  * 이 책에서는 최적화 문제를 푸는 여러가지 방법을 다루고 있으며, 가장 기초적인 것은 역시 **완전탐색**을 이용하는 것이다
  * 왜냐하면 가능한 방법을 다 찾아보면 그 중에서 제일 좋은 답을 찾아내는 것도 가능하기 때문이다
* 예제: 여행하는 외판원 문제 (TSP)
  * TSP(Traveling Salesman Probelm)은 매우 유명한 문제이다
  * 어떤 나라에 n (2<=n<=10) 개의 도시가 있다고 가정하자
  * 한 영업사원이 한 도시에서 출발해 모든 도시들을 한 번씩 방문한 뒤 처음 도시로 돌아오려 한다
  * 이 때, 가장 짧은 거리로 방문하는 방법은 어떻게 찾을 수 있을까?
* 무식하게 풀 수 있을까?
  * 일단 n 개의 도시가 있다고 가정하면 (n-1)! 이다, O(N!)
  * 10개의 도시를 가정했기 때문에 9! = 362,880 이다, 해결가능하다
  * 그러나 도시가 14개만 되도 13! = 6,227,020,800 , 60억개 이므로 주먹구구 법칙을 토대로 실패할 가능성이 크다
    ![](https://github.com/ant35rookie/share/blob/master/docs/ch6/88.png)
* 재귀호출을 통한 답안 생성 (코드 6.7)
  ```c++
  int n;  // 도시의 수
  double dist[MAX][MIN];  // 두 도시 간의 거리를 저장하는 배열
  
  // path : 지금까지 만든 경로
  // visited : 각 도시의 방문 여부
  // currentLength: 지금까지 만든 경로의 길이
  // 나머지 도시들을 모두 방문하는 경로들 중 가장 짧은 것의 길이를 반환한다
  double shortestPath(vector<int>& path, vector<bool>& visited, double currentLength) {
      // 기저사례: 모든 도시를 다 방문했을 떄는 시작 도시로 돌아가고 종료한다
      if(path.size == n)
          return currentLength + dist[path[0]][path.back()];
      
      double ret = INF;	// 매우 큰 값으로 초기화 (확인안된 경로는 거리가 무한대라는 의미)
      // 다음 방문할 도시를 전부 시도해 본다
      for(int next = 0; next < n; ++next) {
          if(visited[next])
              continue;
          
          int here = path.back();
          path.push_back(next);
          visited[next] = true;
          
          // 나머지 경로를 재귀 호출을 통해 완성하고 가장 짧은 경로의 길이를 얻는다
          double cand = shortestPath(path, visited, currentLength + dist[here][next]);
          ret = min(ret, cand);
          visited[next] = flase;
          path.pop_back();
      }
      return ret;
  }
  ```

## 6.8 문제: 시계 맞추기 (난이도: 중)

* 문제
  * 아래 그림처럼 4 x 4 형태의 16개의 시계가 있다
    ![](https://github.com/ant35rookie/share/blob/master/docs/ch6/99.png)
  * 각각은 12시 / 3시 / 6시 / 9시 중 하나를 가리킨다
  * 시간을 바꾸는 방법은 스위치를 누르는 것이다
    * 스위치는 각 시계를 3시간씩 앞으로 움직이게 한다 (12시 > 3시로 , 3시 > 6시로 ...)
    * 1개의 스위치는1개 이상의 시계와 연결되어 있다
    * 예를 들면 아래와 같으며, 시계 번호는 최상단왼쪽의 0부터 시작해서 오른쪽으로 갈수록 1씩 증가된다
      ![](https://github.com/ant35rookie/share/blob/master/docs/ch6/1010.png)
  * 모든 시계가 12시를 가리키도록 하는데 필요한 스위치를 누르는 최소 회수를 구하라
* 시간 및 메모리 제한
  * 10초 이내, 64MB 이하 메모리만 사용
* 입력
  * 첫 줄 : 테스트 케이스 개수 C (C<= 30)
  * 각 테스트 케이스 : 16개 시계가 현재 가리키는 시간
* 출력
  * 각 테스트 케이스당 정수 하나를 한 줄에 출력한다
  * 이 정수들은 모든 시계를 12시로 바꾸는데 필요한 최소한의 스위치 누름횟수이다
  * 불가능한 경우 -1 을 출력한다
* 예제입력
  ```shell
  2
  12 6 6  6 6 6 12 12 12 12 12 12 12 12 12 12 
  12 9 3 12 6 6  9  3 12  9 12  9 12 12  6  6 
  ```
* 예제출력
  ```shell
  2
  9
  ```
* 예제 입출력 설명
  * 첫번째 테스트케이스는 8번 스위치를 누르면 해결된다 (예제출력은 2번인데 8번...?)
  * 두번째 테스트케이스는 여러가지 방법이 있지만, 아래와 같이 누르면 9번 만에 된다
    * 스위치 누르는 순서 : 0, 1, 5, 6, 6, 6, 6, 3, 7

## 6.9 풀이: 시계 맞추기

* 문제 변형하기
  * 있는 그대로 풀려면 매우 복잡한 문제이다
  * 단순화 한다
    * 스위치를 누르는 순서는 결과에 영향을 주지 않는다
      * 밑에 간단예제에서 이유 확인, 기본적으로는 각 시계는 자기만 독립적으로 돌아가기 때문에 (연쇄반응 X)
    * 따라서 스위치를 몇 번 눌러야 하는지만 신경쓰면 된다
    * 여기까지 알았다고 해도 완전 탐색 알고리즘을 바로 적용하면 조합의 수는 무한하기 때문에 안된다
      * 왜냐하면 시계를 계속 돌릴 수 있기 때문에 끝이 없는 것이다
    * 각 시계는 12시간이 지나면 제 자리로 돌아온다
      * 즉, 어떤 시계와 연결된 스위치를 4번 누르는 것은 제자리이기 때문에 의미가 없다
        (하나도 누르지 않은 것과 같다)
      * 이말은 따라서 **어떤 스위치든 3번 이상 누르는 것은 의미가 없다**가 된다
        (스위치를 누르는 회수 : 0 <= n <= 3)
      * 예제에서는 10개의 스위치가 있으므로 모든 경우의 수는 4^10 = 1,048,576 이 된다
      * 이제, 문제가 주먹구구 방법에 의거해 완전탐색으로 해볼만한 문제임을 알게 되었다
* 완전 탐색 구현하기 (코드 6.8)
  ```c++
  const int INF = 9999, SWITCHES = 10, CLOCKS = 16;
  
  // linked[i][j] = 'x' : i 번 스위치와 j 번 시계가 연결되어 있다
  // linked[i][j] = '.' : i 번 스위치와 j 번 시계는 연결되어 있지 않다
  // CLOCKS+1 은 character 형태이기 때문에 NULL 추가한 것
  const char linked[SWITCHES][CLOCKS+1] = {
  	"xxx.............",
      "...x...x.x.x....",
      "....x.....x...xx",
      "x...xxxx........",
      "......xxx.x.x...",
      "x.x...........xx",
      "...x..........xx",
      "....xx.x......xx",
      ".xxxxx..........",
      "...xxx...x...x.."
  };
  
  // areAligned함수 : 모든 시계가 12시를 카리키고 있는지 확인하는 함수 (구현 생략)
  bool areAligned(const vector<int>& clocks);
  
  // push함수 : swtch 번 스위치를 누르는 함수
  void push(vector<int>& clocks, int swtch) {
      for(int clock = 0; clock < CLOCKS; ++clock) {
          if(linked[swtch][clock] == 'x') {
              clocks[clock] += 3;
              if(clocks[clock] == 15)
                  clocks[clock] = 3;
          }
      }
  }
  
  // solve함수 : 남은 스위치들을 눌러서 clocks를 12시로 맞출 수 있는 최소 횟수를 반환한다
  // clocks: 현재 시계들의 상태
  // swtch : 이번에 누를 스위치의 번호
  // 만약 불가능하다면 INF 이상의 큰 수를 반환한다
  int solve(vector<int>& clocks, int swtch) {
      if(swtch == SWITCHES)
          return areAligned(clocks) ? 0 : INF;
      
      // 이 스위치를 0번 누르는 경우부터 3번 누르는 경우까지를 모두 시도한다
      int ret = INF;
      for(int cnt = 0; cnt <4; ++cnt) {
          ret = min(ret, cnt + solve(clocks, swtch + 1));
          push(clocks, swtch);
      }
      
      // push(clocks, swtch)가 4번 호출되었으니 clocks는 원래와 같은 상태가 된다
      return ret;
  }
  ```
  * 소스코드 이해하기
  ![](https://github.com/ant35rookie/share/blob/master/docs/ch6/20190501_201023(1).jpg)
  
## 6.10 많이 등장하는 완전탐색 유형
* 모든 순열 만들기
  * nPr = n! / (n-r)!
  * 재귀함수로 구현할 수 있어야 한다
  * 순열로 완전탐색을 할 때, N이 10을 넘어가는 경우는 일단 위험하긴 하다 (주먹구구 법칙을 기반으로)
  * 이 때는 다른 방법을 선택한다,  9.11 에서 그러한 방법을 다룬다
  * C++의 경우, 다른 언어와 다르게 next_permuation() 함수를 제공하기 때문에 순열을 구현할때 조금 유리하다
  ```
  #include <string>
  #include <iostream>
  #include <algorithm>

  using namespace std;
 
  int main()
  {
    string s = "abaac";
    sort(s.begin(), s.end());
    
    int cnt = 0;
    
    do {
        cnt++;
    } while(next_permutation(s.begin(), s.end()));
    
    cout << "result: " << cnt << endl;
  }
  ```
  * 위 프로그램의 수행결과는 20이 나온다 (5P5 / 3! = 5! / 3! = 20)
* 모든 조합 만들기
  * nCr = n! / r!(n-r)!
  * 재귀함수로 구현할 수 있어야 한다
